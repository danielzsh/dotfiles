snippet cpac
	#include <iostream>
	#define int long long
	#define exit(X) { cout << (X); return; }
	using namespace std;
	using P = pair<int, int>;
	const int inf = 1e18;

	const int N = ${0};

	void ac() {

	}

	signed main() {
		cin.tie(0)->sync_with_stdio(0); 
		int t; cin >> t;
		while (t--) ac();
	}

snippet egcd
	// ---extended euclidean algorithm---
	int gcd(int a, int b, int& x, int& y) {
		x = 1, y = 0;
		int x1 = 0, y1 = 1, a1 = a, b1 = b;
		while (b1) {
			int q = a1 / b1;
			tie(x, x1) = make_tuple(x1, x - q * x1);
			tie(y, y1) = make_tuple(y1, y - q * y1);
			tie(a1, b1) = make_tuple(b1, a1 - q * b1);
		}
		return a1;
	}
	int gcd(int a, int b) { int x, y; return gcd(a, b, x, y); }

	int inv(int a, int m) {
		int x, y;
		gcd(a, m, x, y);
		return x % m;
	}

snippet phi
	// ---euler's totient funtion---
	int phi(int n) {
			int result = n;
			for (int i = 2; i * i <= n; i++) {
					if (n % i == 0) {
							while (n % i == 0)
									n /= i;
							result -= result / i;
					}
			}
			if (n > 1)
					result -= result / n;
			return result;
	}

snippet modac
	const int M = ${0};
	int E(int x, int y) { int r = 1; for (y <<= 1; y >>= 1; x = x * x % M) if (y & 1) r = r * x % M; return r; }
	int inv(int x) { return E(x, M - 2); }
	int sb(int x, int y) { return ((x - y) % M + M) % M; }
	int ad(int& x, int y) { return x = (x + y) % M; }

snippet combo
	int F[${0}], F_i[${1}];
	void pre(int n) { F[0] = F_i[0] = 1; for (int i = 1; i < n; i++) F_i[i] = inv(F[i] = F[i - 1] * i % M); }
	int C(int n, int k) { return F[n] * F_i[n - k] % M * F_i[k] % M; }

snippet sieve
	bool np[N];
	void sieve() {
		for (int i = 2; i < N; i++) if (!np[i]) {
			for (int j = 2 * i; j < N; j += i) np[i] = true;
		}
	}

snippet dinic
	struct E {
		int y, id, cap;
	};
	vector<E> g[N * N];
	vector<E>::iterator e[N * N];

	void add_edge(int x, int y, int cap) {
		g[x].push_back({y, t++, cap});
		g[y].push_back({x, t++, 0});
	}

	bool bfs(int s, int t) {
		for (int i = 0; i <= t; i++) lv[i] = inf;
		queue<int> q;
		q.push(lv[s] = 0);
		while (q.size()) {
			int x = q.front(); q.pop();
			if (x == t) return true;
			for (auto [y, id, cap] : g[x]) if (cap > f[id] && lv[y] > lv[x] + 1) {
				lv[y] = lv[x] + 1; q.push(y);
			}
		}
		return false;
	}

	int dfs(int x, int fl, int t) {
		if (x == t) return fl;
		for (; e[x] != g[x].end(); e[x]++) {
			auto [y, id, cap] = *e[x];
			if (lv[y] != lv[x] + 1 || f[id] >= cap) continue; 
			int nf = dfs(y, min(fl, cap - f[id]), t);
			if (nf > 0) {
				f[id] += nf, f[id^1] -= nf;
				return nf;
			}
		}
		return 0;
	}

	int dinic(int s, int t) {
		int r = 0;
		while (bfs(s, t)) {
			for (int i = 0; i <= t; i++) e[i] = g[i].begin();
			while (int x = dfs(s, inf, t)) {
				r += x;
			}
		}
		return r;
	}

snippet randomac
	mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());

snippet sparse
	int st[N][K];
	//---SPARSE TABLE---
	void build() {
		for (int i = 0; i < n; i++) st[i][0] = a[i];
		for (int k = 1; k < K; k++) for (int i = 0; i < n; i++) {
			st[i][k] = st[i][k - 1];
			if (int j = i + (1 << k - 1); j < n) st[i][k] = min(st[i][k], st[j][k - 1]);
		}
	}

	int mn(int l, int r) { // min on [l, r)
		int k = log2(r - l);
		return min(st[l][k], st[r - (1 << k)][k]);
	}
snippet matrix
	template <int... D> struct T {
		int v = 0;
		void operator*= (int x) { v = v * x % M; }
		void operator+= (int x) { v = ad(v, x); }
		void operator-= (int x) { v = sb(v, x); }
		void operator+= (T<> x) { *this += x.v; }
		void operator-= (T<> x) { *this -= x.v; }
		void operator= (int x) { v = x; }
		string str() { return to_string(v); }
	};
	template <int N, int... D> struct T<N, D...> {
		T<D...> a[N];
		T<N, D...> operator* (int v) {
			auto o = *this;
			for (int i = 0; i < N; i++) o[i] *= v;
			return o;
		}
		void operator*= (int v) { *this = *this * v; }
		T<N, D...> operator+ (T<N, D...> b) {
			auto o = *this;
			for (int i = 0; i < N; i++) o[i] += b[i];
			return o;
		}
		void operator+= (T<N, D...> b) { *this = *this + b; }
		void operator-= (T<N, D...> b) {
			for (int i = 0; i < N; i++) a[i] -= b[i];
		}
		T<D...>& operator[] (int i) { return a[i]; }
		string str() {
			string s = "";
			for (int i = 0; i < N; i++) s += a[i].str() + (sizeof...(D) ? "\n" : " ");
			return s;
		}
		void gauss(int n) {
			for (int i = 0; i <= n; i++) {
				if (!a[i][i].v) {
					int r = i; 
					for (int j = i + 1; j <= n; j++) if (a[j][i].v) r = j; 
					assert(a[r][i].v);
					swap(a[i], a[r]);
				}
				a[i] *= inv(a[i][i].v);
				for (int j = 0; j <= n; j++) if (j != i) {
					a[j] += a[i] * (M - a[j][i].v);
				}
			}
		}
	};

snippet poly
	const int N = 1 << 19;

	using ll = long long;
	struct mint;
	using P = pair<mint, mint>;
	struct mint {
		const static ll M = 998244353;
		ll v = 0;
		mint() {}
		mint(ll v) { this->v = (v % M + M) % M; }
		mint operator+(const mint &o) const { return v + o.v; }
		mint operator*(const mint &o) const { return v * o.v; }
		mint operator-(const mint &o) const { return v - o.v; }
		mint E(ll y) const { mint r = 1, x = v; for (y <<= 1; y >>= 1; x = x * x) if (y & 1) r = r * x; return r; }
		mint inv() const { return E(M - 2); }
		mint sym() { return E((M - 1) / 2); } // legendre symbol: 1 -> qresidue, -1 -> non-residue
		friend istream& operator>>(istream& s, mint& v) { s >> v.v; return s; }
		friend ostream& operator<<(ostream& s, const mint& v) { s << v.v; return s; }
		mint sqrt() {
			if (!v) return 0;
			mint i = 1; while ((i * i - v).sym().v != M - 1) i = i + 1;
			mint w = i * i - v;
			auto mul = [&](P x, P y) { return P{
				x.first * y.first + x.second * y.second * w,
				x.first * y.second + x.second * y.first
			}; }; 
			P c = {i, 1}, r = {1, 0};
			for (ll i = 1; i < 2 * M; i <<= 1) {
				if (((M + 1) / 2) & i) r = mul(r, c);
				c = mul(c, c);
			}
			assert(r.second.v == 0 && (r.first * r.first).v == v);
			if (r.first.v < M / 2) return r.first;
			return r.first * -1;
		}
		mint operator/(mint o) { return *this * o.inv(); }
	};

	const mint i2 = mint(2).inv();

	template <int N> struct F {
		static inline const mint w = mint(3).E((mint::M - 1) / N);
		static inline const mint iw = w.inv();
		static inline mint p[N]{}, ip[N]{};
		array<mint, N> a{};
		F<N>(initializer_list<mint> l = {}) {
			assert(!l.size() || l.size() == N);
			int i = 0; for (mint x : l) a[i++] = x;
			if (p[0].v) return;
			p[0] = 1; for (int i = 1; i < N; i++) p[i] = p[i - 1] * w; 
			ip[0] = 1; for (int i = 1; i < N; i++) ip[i] = ip[i - 1] * iw;
		}
		template<int K>
		F<K> slice() const { F<K> f; for (int i = 0; i < min(K, N); i++) f[i] = a[i]; return f; }
		F<N>& fft(bool inv = false) {
			for (int _ = 1; _ < N; _ <<= 1) {
				int s = inv ? _ : N / 2 / _; // stride
				for (int i = 0; i < N; i++) if (!(i & s)) {
					mint W = (inv ? ip : p)[N / 2 / s * (i & (s - 1))];
					mint x = a[i], y = a[i | s];
					if (inv) a[i] = (x + y * W) * i2, a[i | s] = (x - y * W) * i2;
					else a[i] = x + y, a[i | s] = (x - y) * W;
				}
			} 
			return *this;
		}
		mint& operator[](int i) { return a[i]; }
		const mint& operator[](int i) const { return a[i]; }
		// pointwise multiplication
		void operator*= (F<N> &f) { for (int i = 0; i < N; i++) a[i] = a[i] * f[i]; }
		// multiplication by scalar
		void operator*= (const mint &v) { for (int i = 0; i < N; i++) a[i] = a[i] * v; }
		F<N> operator* (const mint &v) const { F<N> f = *this; f *= v; return f; }
		// addition by scalar
		void operator+= (const mint &v) { a[0] = a[0] + v; }
		F<N> operator+ (const mint &v) const { F<N> f = *this; f += v; return f; }
		// adding two polynomials
		template <int K>
		F<N> operator+ (const F<K> &&o) const { F<N> f = *this; for (int i = 0; i < min(N, K); i++) f[i] = f[i] + o[i]; return f; } 
		// convolution
		F<N << 1> operator* (const F<N> &o) const {
			F<N << 1> A = slice<N << 1>(), B = o.template slice<N << 1>();
			A.fft() *= B.fft();
			return A.fft(true);
		}
		friend ostream& operator<<(ostream& s, F<N> f) {
			cout << N << ": ";
			for (int i = 0; i < N; i++) cout << f[i] << " ";
			return s;
		}
		// multiplicative inverse (mod x^N)
		template <int K>
		F<K << 1> invl(F<K> &&f) {
			auto F = f.template slice<K << 1>();
			auto g = F * (F * slice<K << 1>() * -1 + 2).template slice<K << 1>();
			return g.template slice<K << 1>();
		}
		template <int K>
		F<N> inv(F<K> &&f) {
			if constexpr (K == N) return f;
			else return inv<K << 1>(invl(std::move(f)));
			
		}
		F<N> inv() { assert(a[0].v); return inv(F<1>{a[0].inv()}); }

		F<N << 1> operator/(F<N> &f) { return *this * f.inv(); }

		// square root (mod x^N)
		template <int K>
		F<K << 1> sqrtl(F<K> &&f) {
			auto g = f.template slice<K << 1>();
			return (g + (slice<K << 1>() / g)) * i2;
		}
		template <int K>
		F<N> sqrt(F<K> &&f) {
			if constexpr (K == N) return f;
			else return sqrt<K << 1>(sqrtl(std::move(f)));
		}
		F<N> sqrt() { assert(a[0].sym().v == 1); return sqrt(F<1>{a[0].sqrt()}); }
	};
