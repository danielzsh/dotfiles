snippet cpac
	#include <iostream>
	#define int long long
	using namespace std;

	const int inf = 1e18;

	const int N = ${0};

	signed main() {
		cin.tie(0)->sync_with_stdio(0);	

	}

snippet egcd
	// ---extended euclidean algorithm---
	int gcd(int a, int b, int& x, int& y) {
		x = 1, y = 0;
		int x1 = 0, y1 = 1, a1 = a, b1 = b;
		while (b1) {
			int q = a1 / b1;
			tie(x, x1) = make_tuple(x1, x - q * x1);
			tie(y, y1) = make_tuple(y1, y - q * y1);
			tie(a1, b1) = make_tuple(b1, a1 - q * b1);
		}
		return a1;
	}
	int gcd(int a, int b) { int x, y; return gcd(a, b, x, y); }

	int inv(int a, int m) {
		int x, y;
		gcd(a, m, x, y);
		return x % m;
	}

snippet phi
	// ---euler's totient funtion---
	int phi(int n) {
			int result = n;
			for (int i = 2; i * i <= n; i++) {
					if (n % i == 0) {
							while (n % i == 0)
									n /= i;
							result -= result / i;
					}
			}
			if (n > 1)
					result -= result / n;
			return result;
	}

snippet modac
	const int M = ${0};
	int E(int x, int y) {
		int r = 1;
		for (y <<= 1; y >>= 1; x = x * x % M) if (y & 1) r = r * x % M;
		return r;
	}
	int inv(int x) { return E(x, M - 2); }
	int sb(int x, int y) { return ((x - y) % M + M) % M; }
	int ad(int& x, int y) { return x = (x + y) % M; }

snippet combo
	int F[${0}], F_i[${1}];
	void pre(int n) { F[0] = F_i[0] = 1; for (int i = 1; i < n; i++) F_i[i] = inv(F[i] = F[i - 1] * i % M); }
	int C(int n, int k) { return F[n] * F_i[n - k] % M * F_i[k] % M; }
